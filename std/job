# shellcheck shell=bash
# @src std/list
# @src std/utils

# One bash only have one queue?

job.get_active_size(){
    jobs -r | wc -l | tr -d ' '
}

job.offer(){
    local MAX=${1:?Provide the max number of jobs could hold}
    shift
    local cur
    cur=$(job.get_active_size)
    if [ "$cur" -le "${MAX:-3}" ]; then
        (eval "$@") 1>&1 2>&2 &
        return 0
    fi
    return 1
}

# Will block
job.put(){
    until job.offer "$@"; do
        sleep "${interval:-3s}"
    done
}

job.wait_until_finished(){
    local s
    while :; do
        s=$(job.get_active_size)
        [ "$s" -eq 0 ] && return
        sleep 1s
    done
}

job.test.ping(){
    local outfile=${1:?Provide output file path}
    for ip in ${2:?Provide ip range like 192.168.6}.{1..255}; do 
        echo "$ip"
        job.put 100 "ping -c 2 $ip 1>/dev/null 2>&1 && echo $ip >>$outfile"; 
    done
    job.wait_until_finished
}

# @src std/list
job.pool.create(){
    eval "export ${1:?Provide queue name}=()"
    eval "export $1_max=${2:-6}"
    export O=$1
}

job.pool.set_max(){
    eval "export ${O:?Provide queue size}_max=3"
}

job.pool.get_max(){
    eval "echo \$${O:?Provide queue size}_max"
}

job.pool.get_active_size(){
    jobs -r | wc -l | tr -d ' '
}

job.pool.offer(){
    local cur max
    cur=$(jobpool.get_active_size)
    max=$(jobpool.get_max)
    if [ "$cur" -le "$max" ]; then
        (eval "$@") 1>&1 2>&2 &
        return 0
    fi
    return 1
}

# Will block
job.pool.put(){
    until jobpool.offer "$@"; do
        sleep 3s;
    done
}

job.pool.clear(){
    eval "export $1=()"
}

job.pool.wait_until_finished(){
    local s
    while :; do
        s=$(job.pool.get_active_size)
        [ "$s" -eq 0 ] && return
        sleep 1s
    done
}

job.pool.test.ping(){
    local outfile=${1:?Provide output file path}
    jobpool.create queue4ping 100
    for ip in ${2:?Provide ip range like 192.168.6}.{1..255}; do
        echo "$ip"
        jobpool.put "ping -c 2 $ip && echo $ip >>$outfile";
    done
    jobpool.clear
}


